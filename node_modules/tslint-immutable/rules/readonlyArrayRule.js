"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Lint = require("tslint");
var utils = require("tsutils/typeguard/2.8");
var Ignore = require("./shared/ignore");
var check_node_1 = require("./shared/check-node");
var typeguard_1 = require("./shared/typeguard");
// tslint:disable-next-line:variable-name
exports.Rule = check_node_1.createCheckNodeRule(Ignore.checkNodeWithIgnore(checkNode), "Only ReadonlyArray allowed.");
function checkNode(node, ctx) {
    return {
        invalidNodes: checkArrayType(node, ctx).concat(checkTypeReference(node, ctx), checkImplicitType(node, ctx))
    };
}
function checkArrayType(node, ctx) {
    // We need to check both shorthand syntax "number[]"...
    if (utils.isArrayTypeNode(node)) {
        if (node.parent &&
            Ignore.shouldIgnorePrefix(node.parent, ctx.options, ctx.sourceFile)) {
            return [];
        }
        if (ctx.options.ignoreRestParameters &&
            node.parent &&
            utils.isParameterDeclaration(node.parent) &&
            node.parent.dotDotDotToken) {
            return [];
        }
        if (ctx.options.ignoreReturnType && checkIsReturnType(node)) {
            return [];
        }
        return [
            check_node_1.createInvalidNode(node, [
                new Lint.Replacement(node.getStart(ctx.sourceFile), 0, "ReadonlyArray<"),
                new Lint.Replacement(node.end - 2, 2, ">")
            ])
        ];
    }
    return [];
}
function checkTypeReference(node, ctx) {
    // ...and type reference "Array<number>"
    if (utils.isTypeReferenceNode(node) &&
        node.typeName.getText(ctx.sourceFile) === "Array") {
        if (node.parent &&
            Ignore.shouldIgnorePrefix(node.parent, ctx.options, ctx.sourceFile)) {
            return [];
        }
        if (ctx.options.ignoreReturnType && checkIsReturnType(node)) {
            return [];
        }
        return [
            check_node_1.createInvalidNode(node, [
                new Lint.Replacement(node.getStart(ctx.sourceFile), 0, "Readonly")
            ])
        ];
    }
    return [];
}
function checkImplicitType(node, ctx) {
    if (Ignore.shouldIgnorePrefix(node, ctx.options, ctx.sourceFile)) {
        return [];
    }
    // Check if the initializer is used to set an implicit array type
    if (typeguard_1.isVariableOrParameterOrPropertyDeclaration(node) &&
        isUntypedAndHasArrayLiteralExpressionInitializer(node)) {
        var length_1 = node.name.getWidth(ctx.sourceFile);
        var nameText = node.name.getText(ctx.sourceFile);
        var typeArgument = "any";
        return [
            check_node_1.createInvalidNode(node.name, [
                new Lint.Replacement(node.name.end - length_1, length_1, nameText + ": ReadonlyArray<" + typeArgument + ">")
            ])
        ];
    }
    return [];
}
exports.checkImplicitType = checkImplicitType;
function checkIsReturnType(node) {
    return Boolean(node.parent &&
        typeguard_1.isFunctionLikeDeclaration(node.parent) &&
        node === node.parent.type);
}
function isUntypedAndHasArrayLiteralExpressionInitializer(node) {
    return Boolean(!node.type &&
        (node.initializer && utils.isArrayLiteralExpression(node.initializer)));
}
//# sourceMappingURL=readonlyArrayRule.js.map